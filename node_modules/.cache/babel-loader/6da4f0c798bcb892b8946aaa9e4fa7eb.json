{"ast":null,"code":"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactMotion from './react-motion';\nimport './index.css'; // import App from './App';\n// import reportWebVitals from './reportWebVitals';\n// function App() {\n//   return (\n//     <h1>MyApp</h1>\n//   );\n// }\n// ReactDOM.render(\n//   <App />,\n//   document.getElementById('root')\n// );\n// // initializing react component constants\n// const {Component} = React;\n// const {render} = ReactDOM;\n// const {Motion, spring} = ReactMotion;\n// // const {range} = _;\n// // css structure for the style of the tiles themselves\n// const tilesStyle = {\n//   listStyle: 'none',\n//   margin: '0 auto', \n//   padding: 5, \n//   position: 'relative'\n// };\n// // css structure for the each individual tile\n// const tileStyle = {\n//   backgroundColor: 'grey',\n//   boxShadow: 'inset 0 0 1px 0 black',\n//   boxSizing: 'border-box',\n//   display: 'block',\n//   padding: 6,\n//   position: 'absolute'\n// };\n// // css structure for the hole in the game style\n// const holeStyle = {\n//   opacity: 0\n// };\n// // css structure for button (at the bottom)\n// const buttonStyle = {\n//   display: 'block',\n//   margin: '16px auto',\n//   padding: '8px 16px'\n// };\n// // a function that mathematically checks whether or not the \n// // the game is solvable\n// function isSolvable (numbers, rows, cols) {\n//   let product = 1;\n//   for (let i = 1, l = rows*cols-1; i <= l; i++) {\n//     for (let j = i+1, m = l+1; j <= m; j++) {\n//       product *= (numbers[i-1] - numbers[j-1]) / (i-j);\n//     }\n//   }\n//   return Math.round(product) === 1;\n// }\n// // checks to see if the game is solved or not\n// function isSolved(numbers) {\n//   for (let i = 0, l = numbers.length; i < l; i++) {\n//     if(numbers[i] !== i) {\n//       return false;\n//     }\n//   }\n// }\n// // get position in a linear matrix\n// function getLinearPosition({row, col}, rows, cols) {\n//   return parseInt(row, 10) * cols + parseInt(col, 10);\n// }\n// const {Component} = React\n// const {render} = ReactDOM\n// const {Motion, spring} = ReactMotion\n// const {range} = _\n// const tilesStyle = {\n//   listStyle: 'none',\n//   margin: '0 auto',\n//   padding: 5,\n//   position: 'relative'\n// }\n// const tileStyle = {\n//   backgroundColor: 'grey',\n//   boxShadow: 'inset 0 0 1px 0 black',\n//   boxSizing: 'border-box',\n//   display: 'block',\n//   padding: 6,\n//   position: 'absolute'\n// }\n// const holeStyle = {\n//   opacity: 0\n// }\n// const buttonStyle = {\n//   display: 'block',\n//   margin: '16px auto',\n//   padding: '8px 16px'\n// }\n// // Checks if the puzzle can be solved.\n// //\n// // Examples:\n// //   isSolvable([3, 7, 6, 0, 5, 1, 2, 4, 8], 3, 3) // => false\n// //   isSolvable([6, 4, 5, 0, 1, 2, 3, 7, 8], 3, 3) // => true\n// function isSolvable (numbers, rows, cols) {\n//   let product = 1\n//   for (let i = 1, l = rows * cols - 1; i <= l; i++) {\n//     for (let j = i + 1, m = l + 1; j <= m; j++) {\n//       product *= (numbers[i - 1] - numbers[j - 1]) / (i - j)\n//     }\n//   }\n//   return Math.round(product) === 1\n// }\n// // Checks if the puzzle is solved.\n// //\n// // Examples:\n// //   isSolved([6, 4, 5, 0, 1, 2, 3, 7, 8]) // => false\n// //   isSolved([0, 1, 2, 3, 4, 5, 6, 7, 8]) // => true\n// function isSolved (numbers) {\n//   for (let i = 0, l = numbers.length; i < l; i++) {\n//     if (numbers[i] !== i) {\n//       return false\n//     }\n//   }\n//   return true\n// }\n// // Get the linear index from a row/col pair.\n// function getLinearPosition ({row, col}, rows, cols) {\n//   return parseInt(row, 10) * cols + parseInt(col, 10)\n// }\n// // Get the row/col pair from a linear index.\n// function getMatrixPosition (index, rows, cols) {\n//   return {\n//     row: Math.floor(index / cols),\n//     col: index % cols\n//   }\n// }\n// function getVisualPosition ({row, col}, width, height) {\n//   return {\n//     x: col * width,\n//     y: row * height\n//   }\n// }\n// function shuffle (numbers, hole, rows, cols) {\n//   do {\n//     numbers = _.shuffle(_.without(numbers, hole)).concat(hole)\n//   } while (isSolved(numbers) || !isSolvable(numbers, rows, cols))\n//   return numbers\n// }\n// function canSwap (src, dest, rows, cols) {\n//   const {row: srcRow, col: srcCol} = getMatrixPosition(src, rows, cols)\n//   const {row: destRow, col: destCol} = getMatrixPosition(dest, rows, cols)\n//   return (Math.abs(srcRow - destRow) + Math.abs(srcCol - destCol) === 1)\n// }\n// function swap (numbers, src, dest) {\n//   numbers = _.clone(numbers);\n//   [numbers[src], numbers[dest]] = [numbers[dest], numbers[src]]\n//   return numbers\n// }\n// class Tile extends Component {\n//   constructor () {\n//     super()\n//     this.handleClick = this.handleClick.bind(this)\n//   }\n//   handleClick () {\n//     const {index} = this.props\n//     this.props.onClick(index)\n//   }\n//   render () {\n//     const {hole, number, index, rows, cols, width, height} = this.props\n//     const matrixPos = getMatrixPosition(index, rows, cols)\n//     const visualPos = getVisualPosition(matrixPos, width, height)\n//     const motionStyle = {\n//       translateX: spring(visualPos.x),\n//       translateY: spring(visualPos.y)\n//     }\n//     const style = {\n//       ...tileStyle,\n//       ...(number === hole ? holeStyle : {}),\n//       width,\n//       height\n//     }\n//     return (\n//       <Motion style={motionStyle}>\n//         {({translateX, translateY}) => (\n//           <li style={{...style, transform: `translate3d(${translateX}px, ${translateY}px, 0)`}}\n//             onClick={this.handleClick}\n//             >\n//             {number}\n//           </li>\n//         )}\n//       </Motion>\n//     )\n//   }\n// }\n// class Tiles extends Component {\n//   constructor (props) {\n//     super(props)\n//     const {rows, cols} = props\n//     this.state = {numbers: _.range(0, rows * cols)}\n//     this.handleTileClick = this.handleTileClick.bind(this)\n//     this.handleButtonClick = this.handleButtonClick.bind(this)\n//   }\n//   handleTileClick (index) {\n//     this.swap(index)\n//   }\n//   handleButtonClick () {\n//     this.shuffle()\n//   }\n//   shuffle () {\n//     const {hole, rows, cols} = this.props\n//     const {numbers} = this.state\n//     const shuffledNumbers = shuffle(numbers, hole, rows, cols)\n//     this.setState({numbers: shuffledNumbers})\n//   }\n//   swap (tileIndex) {\n//     const {hole, rows, cols} = this.props\n//     const {numbers} = this.state\n//     const holeIndex = numbers.indexOf(hole)\n//     if (canSwap(tileIndex, holeIndex, rows, cols)) {\n//       const newNumbers = swap(numbers, tileIndex, holeIndex)\n//       this.setState({numbers: newNumbers})\n//     }\n//   }\n//   render () {\n//     const {rows, cols, width, height} = this.props\n//     const {numbers} = this.state\n//     const solved = isSolved(numbers)\n//     const pieceWidth = Math.round(width / cols)\n//     const pieceHeight = Math.round(height / rows)\n//     const style = {\n//       ...tilesStyle,\n//       width,\n//       height\n//     }\n//     return (\n//       <div>\n//         <ul style={style}>\n//           {numbers.map((number, index) => (\n//             <Tile {...this.props} index={index} number={number} key={number}\n//               width={pieceWidth} height={pieceHeight}\n//               onClick={this.handleTileClick}\n//             />\n//           ))}\n//         </ul>\n//         <button style={buttonStyle}\n//           onClick={this.handleButtonClick}\n//         >\n//           {solved ? 'Start' : 'Restart'}\n//         </button>\n//       </div>\n//     )\n//   }\n// }\n// class Puzzle extends Component {\n//   render () {\n//     return (\n//       <Tiles rows={3} cols={3} hole={8}\n//         width={300} height={300}\n//       />\n//     )\n//   }\n// }\n// render(<Puzzle />, document.querySelector('#container'))\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();","map":{"version":3,"sources":["/Users/rayaq/Desktop/SlidingPuzzle/sliding-puzzle/src/index.js"],"names":["React","ReactDOM","ReactMotion"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AACA,OAAO,aAAP,C,CACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactMotion from './react-motion';\nimport './index.css';\n// import App from './App';\n// import reportWebVitals from './reportWebVitals';\n\n// function App() {\n//   return (\n//     <h1>MyApp</h1>\n//   );\n// }\n\n// ReactDOM.render(\n//   <App />,\n//   document.getElementById('root')\n// );\n\n// // initializing react component constants\n// const {Component} = React;\n// const {render} = ReactDOM;\n// const {Motion, spring} = ReactMotion;\n// // const {range} = _;\n\n// // css structure for the style of the tiles themselves\n// const tilesStyle = {\n//   listStyle: 'none',\n//   margin: '0 auto', \n//   padding: 5, \n//   position: 'relative'\n// };\n\n// // css structure for the each individual tile\n// const tileStyle = {\n//   backgroundColor: 'grey',\n//   boxShadow: 'inset 0 0 1px 0 black',\n//   boxSizing: 'border-box',\n//   display: 'block',\n//   padding: 6,\n//   position: 'absolute'\n// };\n\n// // css structure for the hole in the game style\n// const holeStyle = {\n//   opacity: 0\n// };\n\n// // css structure for button (at the bottom)\n// const buttonStyle = {\n//   display: 'block',\n//   margin: '16px auto',\n//   padding: '8px 16px'\n// };\n\n// // a function that mathematically checks whether or not the \n// // the game is solvable\n// function isSolvable (numbers, rows, cols) {\n//   let product = 1;\n//   for (let i = 1, l = rows*cols-1; i <= l; i++) {\n//     for (let j = i+1, m = l+1; j <= m; j++) {\n//       product *= (numbers[i-1] - numbers[j-1]) / (i-j);\n//     }\n//   }\n//   return Math.round(product) === 1;\n// }\n\n// // checks to see if the game is solved or not\n// function isSolved(numbers) {\n//   for (let i = 0, l = numbers.length; i < l; i++) {\n//     if(numbers[i] !== i) {\n//       return false;\n//     }\n//   }\n// }\n\n// // get position in a linear matrix\n// function getLinearPosition({row, col}, rows, cols) {\n//   return parseInt(row, 10) * cols + parseInt(col, 10);\n// }\n\n// const {Component} = React\n// const {render} = ReactDOM\n// const {Motion, spring} = ReactMotion\n// const {range} = _\n\n// const tilesStyle = {\n//   listStyle: 'none',\n//   margin: '0 auto',\n//   padding: 5,\n//   position: 'relative'\n// }\n\n// const tileStyle = {\n//   backgroundColor: 'grey',\n//   boxShadow: 'inset 0 0 1px 0 black',\n//   boxSizing: 'border-box',\n//   display: 'block',\n//   padding: 6,\n//   position: 'absolute'\n// }\n\n// const holeStyle = {\n//   opacity: 0\n// }\n\n// const buttonStyle = {\n//   display: 'block',\n//   margin: '16px auto',\n//   padding: '8px 16px'\n// }\n\n// // Checks if the puzzle can be solved.\n// //\n// // Examples:\n// //   isSolvable([3, 7, 6, 0, 5, 1, 2, 4, 8], 3, 3) // => false\n// //   isSolvable([6, 4, 5, 0, 1, 2, 3, 7, 8], 3, 3) // => true\n// function isSolvable (numbers, rows, cols) {\n//   let product = 1\n//   for (let i = 1, l = rows * cols - 1; i <= l; i++) {\n//     for (let j = i + 1, m = l + 1; j <= m; j++) {\n//       product *= (numbers[i - 1] - numbers[j - 1]) / (i - j)\n//     }\n//   }\n//   return Math.round(product) === 1\n// }\n\n// // Checks if the puzzle is solved.\n// //\n// // Examples:\n// //   isSolved([6, 4, 5, 0, 1, 2, 3, 7, 8]) // => false\n// //   isSolved([0, 1, 2, 3, 4, 5, 6, 7, 8]) // => true\n// function isSolved (numbers) {\n//   for (let i = 0, l = numbers.length; i < l; i++) {\n//     if (numbers[i] !== i) {\n//       return false\n//     }\n//   }\n//   return true\n// }\n\n// // Get the linear index from a row/col pair.\n// function getLinearPosition ({row, col}, rows, cols) {\n//   return parseInt(row, 10) * cols + parseInt(col, 10)\n// }\n\n// // Get the row/col pair from a linear index.\n// function getMatrixPosition (index, rows, cols) {\n//   return {\n//     row: Math.floor(index / cols),\n//     col: index % cols\n//   }\n// }\n\n// function getVisualPosition ({row, col}, width, height) {\n//   return {\n//     x: col * width,\n//     y: row * height\n//   }\n// }\n\n// function shuffle (numbers, hole, rows, cols) {\n//   do {\n//     numbers = _.shuffle(_.without(numbers, hole)).concat(hole)\n//   } while (isSolved(numbers) || !isSolvable(numbers, rows, cols))\n//   return numbers\n// }\n\n// function canSwap (src, dest, rows, cols) {\n//   const {row: srcRow, col: srcCol} = getMatrixPosition(src, rows, cols)\n//   const {row: destRow, col: destCol} = getMatrixPosition(dest, rows, cols)\n//   return (Math.abs(srcRow - destRow) + Math.abs(srcCol - destCol) === 1)\n// }\n\n// function swap (numbers, src, dest) {\n//   numbers = _.clone(numbers);\n//   [numbers[src], numbers[dest]] = [numbers[dest], numbers[src]]\n//   return numbers\n// }\n\n// class Tile extends Component {\n//   constructor () {\n//     super()\n    \n//     this.handleClick = this.handleClick.bind(this)\n//   }\n  \n//   handleClick () {\n//     const {index} = this.props\n//     this.props.onClick(index)\n//   }\n  \n//   render () {\n//     const {hole, number, index, rows, cols, width, height} = this.props\n//     const matrixPos = getMatrixPosition(index, rows, cols)\n//     const visualPos = getVisualPosition(matrixPos, width, height)\n//     const motionStyle = {\n//       translateX: spring(visualPos.x),\n//       translateY: spring(visualPos.y)\n//     }\n//     const style = {\n//       ...tileStyle,\n//       ...(number === hole ? holeStyle : {}),\n//       width,\n//       height\n//     }\n    \n//     return (\n//       <Motion style={motionStyle}>\n//         {({translateX, translateY}) => (\n//           <li style={{...style, transform: `translate3d(${translateX}px, ${translateY}px, 0)`}}\n//             onClick={this.handleClick}\n//             >\n//             {number}\n//           </li>\n//         )}\n//       </Motion>\n//     )\n//   }\n// }\n\n// class Tiles extends Component {\n//   constructor (props) {\n//     super(props)\n    \n//     const {rows, cols} = props\n//     this.state = {numbers: _.range(0, rows * cols)}\n    \n//     this.handleTileClick = this.handleTileClick.bind(this)\n//     this.handleButtonClick = this.handleButtonClick.bind(this)\n//   }\n  \n//   handleTileClick (index) {\n//     this.swap(index)\n//   }\n  \n//   handleButtonClick () {\n//     this.shuffle()\n//   }\n  \n//   shuffle () {\n//     const {hole, rows, cols} = this.props\n//     const {numbers} = this.state\n//     const shuffledNumbers = shuffle(numbers, hole, rows, cols)\n//     this.setState({numbers: shuffledNumbers})\n//   }\n  \n//   swap (tileIndex) {\n//     const {hole, rows, cols} = this.props\n//     const {numbers} = this.state\n//     const holeIndex = numbers.indexOf(hole)\n//     if (canSwap(tileIndex, holeIndex, rows, cols)) {\n//       const newNumbers = swap(numbers, tileIndex, holeIndex)\n//       this.setState({numbers: newNumbers})\n//     }\n//   }\n  \n//   render () {\n//     const {rows, cols, width, height} = this.props\n//     const {numbers} = this.state\n//     const solved = isSolved(numbers)\n//     const pieceWidth = Math.round(width / cols)\n//     const pieceHeight = Math.round(height / rows)\n//     const style = {\n//       ...tilesStyle,\n//       width,\n//       height\n//     }\n    \n//     return (\n//       <div>\n//         <ul style={style}>\n//           {numbers.map((number, index) => (\n//             <Tile {...this.props} index={index} number={number} key={number}\n//               width={pieceWidth} height={pieceHeight}\n//               onClick={this.handleTileClick}\n//             />\n//           ))}\n//         </ul>\n//         <button style={buttonStyle}\n//           onClick={this.handleButtonClick}\n//         >\n//           {solved ? 'Start' : 'Restart'}\n//         </button>\n//       </div>\n//     )\n//   }\n// }\n\n// class Puzzle extends Component {\n//   render () {\n//     return (\n//       <Tiles rows={3} cols={3} hole={8}\n//         width={300} height={300}\n//       />\n//     )\n//   }\n// }\n\n// render(<Puzzle />, document.querySelector('#container'))\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"]},"metadata":{},"sourceType":"module"}